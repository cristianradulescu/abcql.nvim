local Parser = require("abcql.lsp.parser")

describe("Parser", function()
  describe("extract_partial_word", function()
    it("should extract word at end of text", function()
      local result = Parser.extract_partial_word("SELECT us")
      assert.are.equal("us", result)
    end)

    it("should extract word with underscores", function()
      local result = Parser.extract_partial_word("SELECT user_na")
      assert.are.equal("user_na", result)
    end)

    it("should return empty string for non-word characters", function()
      local result = Parser.extract_partial_word("SELECT ")
      assert.are.equal("", result)
    end)

    it("should handle empty text", function()
      local result = Parser.extract_partial_word("")
      assert.are.equal("", result)
    end)
  end)

  describe("is_after_table_keyword", function()
    it("should detect FROM keyword", function()
      assert.is_true(Parser.is_after_table_keyword("SELECT * FROM "))
    end)

    it("should detect JOIN keyword", function()
      assert.is_true(Parser.is_after_table_keyword("SELECT * FROM users JOIN "))
    end)

    it("should detect LEFT JOIN keyword", function()
      assert.is_true(Parser.is_after_table_keyword("SELECT * FROM users LEFT JOIN "))
    end)

    it("should detect UPDATE keyword", function()
      assert.is_true(Parser.is_after_table_keyword("UPDATE "))
    end)

    it("should handle case insensitivity", function()
      assert.is_true(Parser.is_after_table_keyword("select * from "))
    end)

    it("should return false for non-table keywords", function()
      assert.is_false(Parser.is_after_table_keyword("SELECT "))
    end)
  end)

  describe("is_after_column_keyword", function()
    it("should detect SELECT keyword", function()
      assert.is_true(Parser.is_after_column_keyword("SELECT "))
    end)

    it("should detect WHERE keyword", function()
      assert.is_true(Parser.is_after_column_keyword("SELECT * FROM users WHERE "))
    end)

    it("should detect ORDER BY keyword", function()
      assert.is_true(Parser.is_after_column_keyword("SELECT * FROM users ORDER BY "))
    end)

    it("should detect comma-separated columns", function()
      assert.is_true(Parser.is_after_column_keyword("SELECT name, "))
    end)

    it("should handle case insensitivity", function()
      assert.is_true(Parser.is_after_column_keyword("select "))
    end)

    it("should return false for non-column keywords", function()
      assert.is_false(Parser.is_after_column_keyword("FROM "))
    end)
  end)

  describe("parse_context", function()
    it("should detect DATABASE context for USE statement", function()
      local context = Parser.parse_context("USE my", 7)
      assert.are.equal("DATABASE", context.type)
      assert.are.equal("my", context.partial)
    end)

    it("should detect TABLE context after FROM", function()
      local context = Parser.parse_context("SELECT * FROM us", 17)
      assert.are.equal("TABLE", context.type)
      assert.are.equal("us", context.partial)
    end)

    it("should detect TABLE context with database qualifier", function()
      local context = Parser.parse_context("SELECT * FROM mydb.us", 22)
      assert.are.equal("TABLE", context.type)
      assert.are.equal("mydb", context.database)
      assert.are.equal("us", context.partial)
    end)

    it("should detect COLUMN context after SELECT", function()
      local context = Parser.parse_context("SELECT na", 10)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("na", context.partial)
    end)

    it("should detect COLUMN context with table qualifier", function()
      local context = Parser.parse_context("SELECT users.na", 16)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("users", context.table)
      assert.are.equal("na", context.partial)
    end)

    it("should detect COLUMN context after WHERE", function()
      local context = Parser.parse_context("SELECT * FROM users WHERE na", 29)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("na", context.partial)
    end)

    it("should detect KEYWORD context by default", function()
      local context = Parser.parse_context("SEL", 4)
      assert.are.equal("KEYWORD", context.type)
      assert.are.equal("SEL", context.partial)
    end)

    it("should handle empty partial", function()
      local context = Parser.parse_context("SELECT ", 8)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("", context.partial)
    end)
  end)

  describe("extract_table_names", function()
    it("should extract table from FROM clause", function()
      local tables = Parser.extract_table_names("SELECT * FROM users")
      assert.are.same({ "users" }, tables)
    end)

    it("should extract table from JOIN clause", function()
      local tables = Parser.extract_table_names("SELECT * FROM users JOIN orders")
      assert.are.same({ "users", "orders" }, tables)
    end)

    it("should handle qualified table names", function()
      local tables = Parser.extract_table_names("SELECT * FROM mydb.users")
      assert.are.same({ "users" }, tables)
    end)

    it("should handle multiple JOINs", function()
      local tables = Parser.extract_table_names("SELECT * FROM users JOIN orders JOIN products")
      assert.are.same({ "users", "orders", "products" }, tables)
    end)

    it("should handle case insensitivity", function()
      local tables = Parser.extract_table_names("select * from users")
      assert.are.same({ "users" }, tables)
    end)

    it("should return empty array for no tables", function()
      local tables = Parser.extract_table_names("SELECT 1")
      assert.are.same({}, tables)
    end)
  end)

  describe("is_sql_keyword", function()
    it("should recognize WHERE as keyword", function()
      assert.is_true(Parser.is_sql_keyword("WHERE"))
    end)

    it("should recognize JOIN as keyword", function()
      assert.is_true(Parser.is_sql_keyword("JOIN"))
    end)

    it("should recognize SELECT as keyword", function()
      assert.is_true(Parser.is_sql_keyword("SELECT"))
    end)

    it("should recognize NULL as keyword", function()
      assert.is_true(Parser.is_sql_keyword("NULL"))
    end)

    it("should return false for non-keywords", function()
      assert.is_false(Parser.is_sql_keyword("users"))
      assert.is_false(Parser.is_sql_keyword("u"))
      assert.is_false(Parser.is_sql_keyword("myalias"))
    end)

    it("should be case-sensitive (expects uppercase)", function()
      assert.is_true(Parser.is_sql_keyword("WHERE"))
      assert.is_false(Parser.is_sql_keyword("where"))
    end)
  end)

  describe("extract_table_aliases", function()
    it("should extract alias with AS keyword", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users AS u")
      assert.are.equal(1, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
      assert.is_nil(mappings[1].database)
    end)

    it("should extract alias without AS keyword", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users u")
      assert.are.equal(1, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
    end)

    it("should extract multiple aliases from JOIN", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users u JOIN orders o")
      assert.are.equal(2, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
      assert.are.equal("orders", mappings[2].table_name)
      assert.are.equal("o", mappings[2].alias)
    end)

    it("should handle database-qualified table names", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM mydb.users AS u")
      assert.are.equal(1, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
      assert.are.equal("mydb", mappings[1].database)
    end)

    it("should handle LEFT JOIN with alias", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users u LEFT JOIN orders o")
      assert.are.equal(2, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("orders", mappings[2].table_name)
    end)

    it("should handle case insensitivity", function()
      local mappings = Parser.extract_table_aliases("select * from users u")
      assert.are.equal(1, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
    end)

    it("should filter out SQL keywords as aliases", function()
      -- WHERE should not be treated as an alias
      local mappings = Parser.extract_table_aliases("SELECT * FROM users WHERE id = 1")
      assert.are.equal(0, #mappings)
    end)

    it("should handle multiple aliases with different styles", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users AS u JOIN orders o JOIN products AS p")
      assert.are.equal(3, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
      assert.are.equal("orders", mappings[2].table_name)
      assert.are.equal("o", mappings[2].alias)
      assert.are.equal("products", mappings[3].table_name)
      assert.are.equal("p", mappings[3].alias)
    end)

    it("should return empty array when no aliases present", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users")
      assert.are.equal(0, #mappings)
    end)

    it("should handle complex query with WHERE clause", function()
      local mappings = Parser.extract_table_aliases("SELECT * FROM users u WHERE u.id = 1")
      assert.are.equal(1, #mappings)
      assert.are.equal("users", mappings[1].table_name)
      assert.are.equal("u", mappings[1].alias)
    end)
  end)

  describe("resolve_alias", function()
    it("should resolve simple alias", function()
      local query = "SELECT * FROM users u WHERE u.id = 1"
      local table_name, database = Parser.resolve_alias("u", query)
      assert.are.equal("users", table_name)
      assert.is_nil(database)
    end)

    it("should resolve alias with database qualifier", function()
      local query = "SELECT * FROM mydb.users u"
      local table_name, database = Parser.resolve_alias("u", query)
      assert.are.equal("users", table_name)
      assert.are.equal("mydb", database)
    end)

    it("should resolve correct alias from multiple tables", function()
      local query = "SELECT * FROM users u JOIN orders o"
      local table_name1, _ = Parser.resolve_alias("u", query)
      local table_name2, _ = Parser.resolve_alias("o", query)
      assert.are.equal("users", table_name1)
      assert.are.equal("orders", table_name2)
    end)

    it("should return nil for unknown alias", function()
      local query = "SELECT * FROM users u"
      local table_name, database = Parser.resolve_alias("unknown", query)
      assert.is_nil(table_name)
      assert.is_nil(database)
    end)

    it("should handle case insensitivity", function()
      local query = "SELECT * FROM users u"
      local table_name1, _ = Parser.resolve_alias("u", query)
      local table_name2, _ = Parser.resolve_alias("U", query)
      assert.are.equal("users", table_name1)
      assert.are.equal("users", table_name2)
    end)
  end)

  describe("parse_context with alias resolution", function()
    it("should resolve alias in COLUMN context", function()
      local query = "SELECT * FROM users u WHERE u.na"
      local context = Parser.parse_context("WHERE u.na", 11, query)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("users", context.table)
      assert.are.equal("na", context.partial)
      assert.are.equal("u", context.resolved_from_alias)
    end)

    it("should resolve alias with database qualifier", function()
      local query = "SELECT * FROM mydb.users u WHERE u.na"
      local context = Parser.parse_context("WHERE u.na", 11, query)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("users", context.table)
      assert.are.equal("mydb", context.database)
      assert.are.equal("na", context.partial)
      assert.are.equal("u", context.resolved_from_alias)
    end)

    it("should handle non-aliased table qualifier", function()
      local query = "SELECT * FROM users WHERE users.na"
      local context = Parser.parse_context("WHERE users.na", 15, query)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("users", context.table)
      assert.are.equal("na", context.partial)
      assert.is_nil(context.resolved_from_alias)
    end)

    it("should work without full_query parameter (backward compatible)", function()
      local context = Parser.parse_context("WHERE u.na", 11)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("u", context.table)
      assert.are.equal("na", context.partial)
      assert.is_nil(context.resolved_from_alias)
    end)

    it("should resolve correct alias in multi-table query", function()
      local query = "SELECT * FROM users u JOIN orders o WHERE o.am"
      local context = Parser.parse_context("WHERE o.am", 11, query)
      assert.are.equal("COLUMN", context.type)
      assert.are.equal("orders", context.table)
      assert.are.equal("am", context.partial)
      assert.are.equal("o", context.resolved_from_alias)
    end)
  end)
end)
